<!doctype html><html lang=en-us><head><meta charset=utf-8><title>Application Insight in a cloud native world</title><link href=//cdn.jsdelivr.net rel=dns-prefetch><link href=//cdnjs.cloudflare.com rel=dns-prefetch><link href=//at.alicdn.com rel=dns-prefetch><link href=//fonts.googleapis.com rel=dns-prefetch><link href=//fonts.gstatic.com rel=dns-prefetch><link href=///disqus.com rel=dns-prefetch><link href=//c.disquscdn.com rel=dns-prefetch><link href=//www.google-analytics.com rel=dns-prefetch><meta name=description content="APM products aren&amp;rsquo;t part of your solution - they are part of your problem
 Don&amp;rsquo;t get me wrong - they are for the most part great products and they do absolutely serve a purpose. But, as we move towards a much more distributed world with lots of smaller interconnected applications that are frequently updated and dynamically scaled, I&amp;rsquo;m not sure that these traditional products are the solution. Certainly not in the product format they are in currently where you pay per &amp;ldquo;host&amp;rdquo; or &amp;ldquo;agent&amp;rdquo;."><meta name=twitter:card content="summary"><meta name=twitter:site content="@mr_scottguymer"><meta name=twitter:title content="Application Insight in a cloud native world"><meta name=twitter:description content="APM products aren&amp;rsquo;t part of your solution - they are part of your problem
 Don&amp;rsquo;t get me wrong - they are for the most part great products and they do absolutely serve a purpose. But, as we move towards a much more distributed world with lots of smaller interconnected applications that are frequently updated and dynamically scaled, I&amp;rsquo;m not sure that these traditional products are the solution. Certainly not in the product format they are in currently where you pay per &amp;ldquo;host&amp;rdquo; or &amp;ldquo;agent&amp;rdquo;."><meta name=twitter:image content="/images/scottguymer.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Application Insight in a cloud native world"><meta property="og:description" content="APM products aren&amp;rsquo;t part of your solution - they are part of your problem
 Don&amp;rsquo;t get me wrong - they are for the most part great products and they do absolutely serve a purpose. But, as we move towards a much more distributed world with lots of smaller interconnected applications that are frequently updated and dynamically scaled, I&amp;rsquo;m not sure that these traditional products are the solution. Certainly not in the product format they are in currently where you pay per &amp;ldquo;host&amp;rdquo; or &amp;ldquo;agent&amp;rdquo;."><meta property="og:url" content="https://www.scottguymer.co.uk/post/application-insight-in-a-cloud-native-world/"><meta property="og:image" content="/images/scottguymer.jpg"><meta name=generator content="Hugo 0.64.0"><link rel=canonical href=https://www.scottguymer.co.uk/post/application-insight-in-a-cloud-native-world/><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no,email=no,adress=no"><meta http-equiv=cache-control content="no-transform"><meta name=robots content="index,follow"><meta name=referrer content="origin-when-cross-origin"><meta name=google-site-verification content="Rop88G3o4ZxIlfG_B3VHOKboh8LM_UpKZTB1d1CTbIE"><meta name=theme-color content="#02b875"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta name=apple-mobile-web-app-title content="Scott Guymer"><meta name=msapplication-tooltip content="Scott Guymer"><meta name=msapplication-navbutton-color content="#02b875"><meta name=msapplication-TileColor content="#02b875"><meta name=msapplication-TileImage content="/icons/icon-144x144.png"><link rel=icon href=https://www.scottguymer.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.scottguymer.co.uk/icons/icon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.scottguymer.co.uk/icons/icon-32x32.png><link rel=icon sizes=192x192 href=https://www.scottguymer.co.uk/icons/icon-192x192.png><link rel=apple-touch-icon href=https://www.scottguymer.co.uk/icons/icon-152x152.png><link rel=manifest href=https://www.scottguymer.co.uk/manifest.json><link rel=preload href=https://www.scottguymer.co.uk/styles/main-rendered.min.css as=style><link rel=preload href="https://fonts.googleapis.com/css?family=Lobster" as=style><link rel=preload href=https://www.scottguymer.co.uk/images/scottguymer.jpg as=image><link rel=preload href=https://www.scottguymer.co.uk/images/grey-prism.svg as=image><style>body{background:#f4f3f1url(/images/grey-prism.svg)repeat fixed}</style><link rel=stylesheet href=https://www.scottguymer.co.uk/styles/main-rendered.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lobster"><script src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.2/dist/medium-zoom.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/video.js@7.3.0/dist/video-js.min.css><!--[if lte IE 8]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><script src=https://cdn.jsdelivr.net/npm/videojs-ie8@1.1.2/dist/videojs-ie8.min.js></script><![endif]--><!--[if lte IE 9]><script src=https://cdn.jsdelivr.net/npm/eligrey-classlist-js-polyfill@1.2.20180112/classList.min.js></script><![endif]--></head><body><div class=suspension><a role=button aria-label="Go to top" title="Go to top" class="to-top is-hide"><span class="icon icon-up" aria-hidden=true></span></a><a role=button aria-label="Go to comments" title="Go to comments" class=to-comment href=#disqus_thread><span class="icon icon-comment" aria-hidden=true></span></a></div><header class=site-header><a href=https://www.scottguymer.co.uk/><img class=avatar src=https://www.scottguymer.co.uk/images/scottguymer.jpg alt=Avatar></a><h2 class=title><a href=https://www.scottguymer.co.uk/>Scott Guymer</a></h2><p class=subtitle>~ Software Engineer ~</p><button class=menu-toggle type=button aria-label="Main Menu" aria-expanded=false tab-index=0>
<span class="icon icon-menu" aria-hidden=true></span></button><nav class="site-menu collapsed"><h2 class=offscreen>Main Menu</h2><ul class=menu-list><li class="menu-item
is-active"><a href=https://www.scottguymer.co.uk/>Home</a></li><li class=menu-item><a href=https://www.scottguymer.co.uk/tags/>Tags</a></li><li class=menu-item><a href=https://www.scottguymer.co.uk/about/>About</a></li></ul></nav><nav class="social-menu collapsed"><h2 class=offscreen>Social Networks</h2><ul class=social-list><li class=social-item><a href=mailto:blog@scottguymer.co.uk title=Email aria-label=Email><span class="icon icon-email" aria-hidden=true></span></a></li><li class=social-item><a href=//github.com/scottguymer rel=me title=GitHub aria-label=GitHub><span class="icon icon-github" aria-hidden=true></span></a></li><li class=social-item><a href=//twitter.com/mr_scottguymer rel=me title=Twitter aria-label=Twitter><span class="icon icon-twitter" aria-hidden=true></span></a></li><li class=social-item><a href=//www.linkedin.com/in/scottguymer rel=me title=LinkedIn aria-label=LinkedIn><span class="icon icon-linkedin" aria-hidden=true></span></a></li></ul></nav></header><section class="main post-detail"><header class=post-header><h1 class=post-title>Application Insight in a cloud native world</h1><p class=post-meta>@Scott Guymer · Jun 13, 2018 · 8 min read</p></header><article class=post-content><blockquote><p>APM products aren&rsquo;t part of your solution - they are part of your problem</p></blockquote><p>Don&rsquo;t get me wrong - they are for the most part great products and they do absolutely serve a purpose. But, as we move towards a much more distributed world with lots of smaller interconnected applications that are frequently updated and dynamically scaled, I&rsquo;m not sure that these traditional products are the solution. Certainly not in the product format they are in currently where you pay per &ldquo;host&rdquo; or &ldquo;agent&rdquo;.</p><p>In my experience there is also the issue that APM solutions seem to provide a false sense of comfort for teams. &ldquo;We have installed XYZ and we have monitoring covered,&rdquo; often with little or no thought put into <em>what</em> we are even interested in monitoring within our applications. Of course, they all come with sensible defaults and give you lots of interesting metrics and graphs to look at, and they will for sure give you <em>some</em> insight into what it going on within your application. Which on the surface of it look great and gives you loads of confidence.</p><p>I don&rsquo;t think its good enough to just install the agent and tick the box. We need to commit a good amount of headspace to what our application should look like in production, what is important to it and also what can and will go wrong that we want to be able to know about and understand. This helps us operate our applications with all of the right information to know our app is not just working, but working correctly.</p><h1 id=what-does-application-insight-look-like>What does Application Insight look like?</h1><p>My current thinking is splitting &ldquo;application insight&rdquo; into 3 distinct but interrelated problems:</p><ul><li>Log Aggregation</li><li>Instrumentation</li><li>Tracing</li></ul><p>We often think of these things collectively as &ldquo;monitoring&rdquo; but I would go further and say that monitoring is what we do with this information, how we aggregate it and use it to give us insight into what is going on. Part of this is ensuring that the system lets us know when it is encountering issues, preferably before they happen.</p><p>Lets break this down and look at the different parts.</p><h2 id=log-aggregation>Log Aggregation</h2><p>Logging is everywhere; everything logs some sort of information. We need to treat this as a stream of events and collect them all together. Its important that although applications don&rsquo;t all have to log the exact same things they need to be doing it in as compatible a format as possible. The most accessible format for most applications is to log to JSON. This has the benefit of being a wide standard and one that can be enriched and adjusted as needed.</p><p>Its important that we focus our logs on things that the application does functionally and not concern ourselves too much with framework or language implementation details. For example, we should be logging the fact that a transaction occurred (or failed) and important information about that transaction, not concerning ourselves with things like the fact that the application invoked certain methods (we will cover that in tracing later).</p><p>We need to then collect all of these logs together into one place and as a minimum be able to search them for important things. Even better if we can set up things like alerts for certain types of logs and the frequency with which they appear.</p><p>So log aggregation is the definition of a standard and also a way of bringing them all into one place. In a kubernetes implementation this is actually quite a trivial thing to do and there are lots of great solutions available out there. Most of them run some sort of collector as DaemonSet with an agent on each node in the cluster. The defacto open source solution in this space is ElasticSearch - FluentD - Kibana.</p><h2 id=instrumentation>Instrumentation</h2><p>Its important that we need teams to apply thought and engineering effort to implementing the right instrumentation for their application. We should move away from the traditional APM style vendors in favour of having each application explicitly have to implement the instrumentation of the metrics it cares most about. This forces development teams to have to think about the way their application operates and what is important to the application during its operation, as well as what is important for understanding the usefulness or success of the application itself. Measuring CPU and RAM are just the context for all other metrics we wish to measure.</p><p>Prometheus is emerging as a defacto standard for instrumenting distributed applications, especially those running on kubernetes. I encourage you to take a look at the <a href=https://prometheus.io>prometheus project</a>; it has some great features and encourages you to think differently about not just the metrics you wish to collect but how to collect them at scale without incurring significant performance penalties.</p><p>To enable us to instrument our code we need to import the Prometheus SDK which is a set of language level features that allow you to create measurements at any point in your code using the built in types of measure that prometheus supports. As prometheus is a standard rather than an implementation there are SDKs available in lots of common languages which means you can use is across your estate no matter what your mix of languages and frameworks.</p><p>Adding specific code to our applications in order to instrument them may seem a bit odd at first and not something we might want to do. However, think of this in the same way you use log lines; they just appear in the code and have little or nothing to do with the actual execution. Being able to understand our app in operation is just as important as having &ldquo;clean code&rdquo;.</p><h2 id=tracing>Tracing</h2><p>Tracing is the act of measuring the way your program executes and is specific to your implementation. This is useful because it shows us the different moving parts internally to our applications and how they interact.</p><p>With distributed systems we need to further concern ourselves with how your application interacts with the other applications which compose your wider system. We need to be able to trace execution between boundaries and get insight into what happened. If each application did this individually this would be a very tedious process as we would have to try and identify individual executions in a sea of data.</p><p>Distributed tracing specifications such as <a href=http://opentracing.io/>OpenTracing</a> define how this should work in an abstract manner that means you can add tracing code to your application without tying yourself into a specific vendor, as you might with more traditional solutions. The OpenTracing API is a standardised spec that is implemented in some 9 languages so far with many differing implementations being available both open source and commercially.</p><p>With OpenTracing we wrap parts of our program execution in &ldquo;spans&rdquo; that measure its execution. We can add further contextual information to the span in the form of tags or logs. A typical trace may look something like this in c#</p><pre><code>using (IScope scope2 = trace.BuildSpan(&quot;httpbinrequest&quot;).StartActive(finishSpanOnDispose: true))
{
    await $&quot;https://httpbin.org/delay/{requestTime}&quot;.GetAsync();
}
</code></pre><p>Its important to understand that the implementations of OpenTracing compliant tracers such as <a href=https://www.jaegertracing.io/>Jaeger</a> rely only on language features and install like an SDK. In this way they rely less on &ldquo;plugging&rdquo; into the runtime and extracting information without your application needing to be aware. This is a great result that makes using later language versions a lot easier and removes a huge upgrade issue when, say, moving from Java 7 to Java 8 and having to wait for a new agent from your APM vendor of choice. It also means that should you choose an unsupported language it is fairly trivial to create a working implementation.</p><h1 id=the-result>The result</h1><p>We need to be able to provide a robust, scalable and opinionated way of collecting application insight across your entire deployment. This will provide the sorts of insight into applications that let us operate them with utter and complete confidence. We need to make this as easy as possible for teams to implement and ensure that it is very much thought of as a benefit to the team. It should be entirely baked into our architecture so that everyone is on the same page.</p><p>Developers need to be asked to implement their own instrumentation within the application so that thought needs to be put into &ldquo;what is important here&rdquo; - in that way we are forcing developers to think about operations at design time. In this way we define what &ldquo;insight&rdquo; each application cares about.</p><h2 id=power-of-peer-review>Power of peer review</h2><p>One of the major and not so obvious benefits in this approach is that we are &ldquo;writing code&rdquo; for our insight. This means that it will have to go through the standard peer review process your teams use. In lots of teams this is a pull request within Git. This means that this code has to be reviewed, discussed and refactored before it makes it into your application.</p><h2 id=deployment>Deployment</h2><p>The other great benefit is that all of this is deployed with your application. Each and every change is deployed as part of your built application. Meaning that all changes have to go through the same pipeline and changes don&rsquo;t have to be done in a different system or control panel. It brings control of the insight back into the code itself and back into your Git repository. Changes can be made and tested on branches without affecting your production configuration and can be tied back to specific deployments and changes.</p></article><footer class=post-footer><ul class=post-tags><li><a href=https://www.scottguymer.co.uk/tags/application-insight><span class=tag>Application Insight</span></a></li><li><a href=https://www.scottguymer.co.uk/tags/monitoring><span class=tag>Monitoring</span></a></li><li><a href=https://www.scottguymer.co.uk/tags/kubernetes><span class=tag>Kubernetes</span></a></li><li><a href=https://www.scottguymer.co.uk/tags/opentracing><span class=tag>OpenTracing</span></a></li><li><a href=https://www.scottguymer.co.uk/tags/prometheus><span class=tag>Prometheus</span></a></li><li><a href=https://www.scottguymer.co.uk/tags/logging><span class=tag>Logging</span></a></li><li><a href=https://www.scottguymer.co.uk/tags/tracing><span class=tag>Tracing</span></a></li></ul><p class=post-copyright>© This post is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License，please give source if you wish to quote or reproduce.This post was published <strong>963</strong> days ago, content in the post may be inaccurate, even wrong now, please take risk yourself.</p></footer><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"scottguymer"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section><footer class=site-footer><p>© 2017-2021 Scott Guymer</p><p>Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> with theme <a href=https://github.com/laozhu/hugo-nuo target=_blank rel=noopener>Nuo</a>.</p></footer><script src=https://cdn.jsdelivr.net/npm/smooth-scroll@15.0.0/dist/smooth-scroll.min.js></script><script async src=https://cdn.jsdelivr.net/npm/video.js@7.3.0/dist/video.min.js></script><script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      displayMath: [['$$','$$'], ['\\[','\\]']],
      processEscapes: true,
      processEnvironments: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      TeX: { equationNumbers: { autoNumber: "AMS" },
      extensions: ["AMSmath.js", "AMSsymbols.js"] }
    },
  });
</script><script type=text/x-mathjax-config>
  // Fix <code> tags after MathJax finishes running. This is a
  // hack to overcome a shortcoming of Markdown. Discussion at
  // https://github.com/mojombo/jekyll/issues/199
  MathJax.Hub.Queue(() => {
    MathJax.Hub.getAllJax().map(v => v.SourceElement().parentNode.className += ' has-jax');
  });
</script><script src=https://www.scottguymer.co.uk/scripts/index.min.js></script><script>if('serviceWorker'in navigator){navigator.serviceWorker.register('\/service-worker.js').then(function(){console.log('[ServiceWorker] Registered');});}</script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-113812052-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>